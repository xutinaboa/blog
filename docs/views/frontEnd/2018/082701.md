---
title: JavaScript函数运行机制——静态作用域与闭包原理
date: 2018-08-27
tags:
 - javascript        
categories: 
 - frontEnd
---

首先来看《JAVASCRIPT权威指南（第六版）》上一段比较精华的话：

> 当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。

这句话上半部分说到当定义一个函数时，它实际上保存一个作用域链。有两个关键字：定义和作用域链，定义说明JS采用的是**静态作用域**，即在函数定义时决定**函数作用域**而不是调用时，因此在其他地方调用函数时都会依据函数定义时的作用域去做变量解析。作用域链说明并不是简单的保存当前定义作用域**变量对象**，还会保存上层函数作用域的变量对象，以此直到全局作用域变量对象，这些变量对象之间形成一条**作用域链**。

接着继续说到当调用这个函数时，它创建一个**变量对象**来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。这句话的上半段在解释**变量解析**和**延长定义作用域链**的过程，当函数调用的时候，首先遍历函数内的所有变量（也包括函数内那些不会执行的代码中的变量），此时函数内的代码还未执行，变量分为声明的和未声明的，如果未声明的变量在函数定义作用域链上，那么不会加入到自身的局部变量的存储对象中，如果未声明的变量不在函数定义作用域链上，那么就会在全局对象上创建一个新的全局变量（非严格模式下）。如果已声明的变量在函数定义的作用域链上，那么在自身局部变量的存储对象中加入该变量且内部函数定义作用域链上的该同名变量也不变，如果已声明的变量不在函数定义的作用域链上，那么它就是局部变量并被加入到自身局部变量的存储对象中，值得注意的是变量解析过程中是不会为变量赋初值的，一切此时加入到作用域的变量都是`undefined`，这个现象也叫叫**变量提升**或者**声明提前**。下半段说同时创建一个新的更长的表示函数调用作用域的“链”。这样看起来就是延长函数定义作用域链，将自身变量对象加入到定义作用域链尾。这里有一个例子可以说明变量解析：

```js
function foo(){
    console.log(c)
    if(false){
        var c = 2
    }
    b = 2 
}
foo()//undefined
console.log(b)//2
```

下半部分说到对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。这句化描述函数的**动态定义**和**动态调用**的过程，每次调用外部函数，每次都会通过变量解析生成变量对象，然后加入到作用域链尾，因此内部函数的定义作用域链也每次定义而不一样，而不是一成不变的。

变量解析的过程打破了JS顺序执行的直观印象，还有个疑惑就是外部的函数调用和内部函数的定义的时候是新生成作用域链而不是公用呢？因为这里调用函数时在开始执行代码之前会创建**执行上下文**，JS采用**执行上下文栈**来管理执行上下文，栈底永远是一个全局执行上下文，函数的调用执行抽象为一个进出栈的过程。每个执行上下文上存在三个引用类型，分别是自身的变量对象、调用作用域链和`this`。变量对象和调用作用域引用的上半段话已经精简的概括，`this`的确定却很复杂，因为客户端全局环境下`this`指向`window`，但局部执行上下文上却是对外不可见的方式，看起来像是对象方法调用时指向调用它的对象，但实际上取决于更底层次的调用的主体是否是一个**Reference**。它在不同的环境下也各不相同，可以从`call`和`bind`的角度去统一的理解下`this`的使用，严格模式下函数调用都为`undefined`，等同于`foo.call(undefined, params)`。方法调用为调用该方法的对象，等同于`obj.foo.call(obj, params)`，`new`将构造函数的`this`给新对象，等同于`Constructor.call(newObj,params)`，而箭头函数和之前几种方式的`this`根本不同在于它是静态词法，即`this`为定义它时的`this`。不会动态变更`this`等同于`bind`加一个简单的**闭包**，如下代码：

```js
var bind = function(func, thisValue) {
  return function() {
    return func.apply(thisValue, arguments);
  }
}
var boundHello = bind(person.hello, person);
```

层级静态函数作用域特点为闭包创造条件，其表现往往是内部函数调用作用域链和定义作用域不是同一条链，而深层次上是执行上下文切换的体现，每次在外部调用闭包都会保存一条闭包定义时的作用域链，它具有持久性，那么闭包在JS中看起来不是一个外部变量访问内部变量的简单行为的概括，而是一个变量对象，这个变量对象是链中的一个节点。如下代码：

```js
var a = 'global';
var b = function(){
    var c = 'local';
    var d = function(){
        return c
    }
    return d
}
b()()
```
执行b和b()时它的作用域链如下:

```js
Scope //b                   Scope//b()
  |----Local                      |----Local
  |  |----c => 'local'            |      |----this => undefined    
  |  |----d => f                  |----Closure(b)
  |  |----this => undefined       |      |----c => 'local' 
  |----Global => Window           |----Global => Window 
```

多个内部函数调用就会存在很多条内部函数调用作用域链并行存在，且每一条链都不一样！内部函数返回的它自身局部变量的对象也会得以保存，而对于同一个内部函数，其闭包变量对象的属性是一直存在的。形成了闭包的两大特性，即**内部共享，外部隔绝**。

*静态作用域，作用域链，变量解析，闭包，执行上下文等来源于《JAVASCRIPT权威指南（第六版）》*

*this用call统一观点来源于[Understanding JavaScript Function Invocation and "this"](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)*

*this的Reference观点来源于[JavaScript深入之从ECMAScript规范解读this](https://github.com/mqyqingfeng/Blog/issues/7)*


