---
title: 构建过程概述  
date: 2018-10-08
tags:
 - webpack        
categories: 
 - frontEnd
---

## 面向语言

出于实践的差距，HTML，CSS和JS从一诞生起就被诟病，主要的点在于环境兼容和语言自身的缺陷。在前端工程化未出现之前，存在预编译的过程，最典型的就是在CSS上应用，比如LESS。前端工程化的出现使得每一种资源都新增一个编译过程，在编译中处理环境兼容和修复语言的缺陷，也甚至是一个转译的过程，比如将TS转译为JS引擎能执行的JS，将Jade转译为浏览器能识别的HTML，这就似乎脱离了语言规范，自成一体。但良好的实践莫过于遵循本身的语言规范，然后在编译的过程中自动处理兼容和缺陷的问题，而不用去人为去关注哪些没有很大必要关注的点。**PostCSS**和**Babel**就是这样做的，如Babel能自动将ES6规范中的代码运行在只支持ES5的JS引擎里，而不用顾虑当前的环境可不可以用这个语法。构建过程在这里可以理解为**面向语言的**。


## 模块化

在无模块化的时代，脚本主要是靠标签引入，这种方式会污染全局作用域，容易产生命名冲突，而且需要着重注意引入模块的顺序问题，且多个模块的依赖关系不明显，不利于维护。**CommonJS规范**通过module.exports、require实现服务端的模块化，解决了全局变量污染和依赖混杂的问题，但它主要是用于服务端的同步加载，不适用客户端的异步加载——如果同步会堵塞DOM构建和渲染。ES6在语言规格的层面上实现了模块功能，它的设计思想是尽量的**静态化**，使得在编译时就能确定模块的依赖关系，以及输入和输出的变量，而CommonJS规范只能在运行时确定这些东西，这使得完全没办法在编译过程中进行静态优化，即CommonJS加载的是一个对象，该对象只有在脚本运行结束时才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。另一个ES6模块输出的是值的引用，而CommonJS输出的是一个值的复制。模块化的发展解决了构建过程重大的JS资源打包的问题，使得所有的JS依赖都可以被有序的输入输出，并可以作为一个根文件称为执行的入口。

## 组件化

长此以往，css和js的模块化是对代码函数化一种提现，即声明一次处处可用，但html一直没有代码复用的支持，jquery和bootstrap早期尝试样式和常用的逻辑来对基础元素封装一个个可复用的插件，但是本质上还是css和js复用。对象模式是另一种尝试，其具体做法是给一个容器，封装的对象逻辑通过传入的配置在容器中增添html代码，如今还有很多库在使用这种方式。其缺点常常是为某个功能而量身定做的，考虑到各种适用和兼容情况，存在代码冗余，且是分散的封闭的静态的，无法与外部进行有效的通信。直到自定义组件化标签的支持和渲染的出现组件化蓬勃发展。因此单文件组件类型对于构建工具来说是另一种语言类型的处理。

## 面向优化

工程化的意义在于对于不同资源的处理，将处理好的资源放在服务器上，以便客户端能更好更快的访问。工程化的构建过程重要的一环就是对资源对于项目的自定义化的优化处理，通用的方式是依赖打包，即分析文件依赖关系，将同步依赖的文件打包在一起，减少HTTP请求数量。资源嵌入，将小于10kb的图片编译为base64格式嵌入到内存中，减少HTTP请求。文件压缩，减少文件体积，缩短请求时间。为每个文件添加hash指纹增量更新，以应对浏览器的缓存策略等等，优化是一个无止尽的过程，会涉及到网络通信和浏览器内核加载资源和网站栈的底层原理。构建过程在这里可以理解为**面向优化**

## 面向开发和部署

编译不仅让语言更具鲁棒性，而且增加语言的容错率（单元测试、继承测试环节），更能高效的进行团队协作（Eslint，爱彼迎规范），这些可谓是语言研发的中间环节。node的加持使得前端领域变得无所不能，开发app，快应用，小程序甚至桌面级应用，这一切都得益于node环境下的文件读写和其他API，而对于工程化而言，快速的路径资源定位，热更新的开发环境、集成化的性能分析、自动化脚手架搭建和自动化部署正是目前必不可需的。构建过程在这里可以理解为**面向开发和部署**。


*本文面向语言、优化和部署的思想均来源于《前端工程化体系设计与实践》*

2018年10月8日



