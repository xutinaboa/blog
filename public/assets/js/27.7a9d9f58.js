(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{527:function(e,a,s){"use strict";s.r(a);var n=s(20),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("全文转载"),s("a",{attrs:{href:"https://github.com/abbshr/abbshr.github.io/issues/22",target:"_blank",rel:"noopener noreferrer"}},[e._v("出处"),s("OutboundLink")],1)]),e._v(" "),s("h4",{attrs:{id:"从realtime说起"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从realtime说起"}},[e._v("#")]),e._v(" 从RealTime说起")]),e._v(" "),s("p",[e._v("自从即时Web的概念提出后，RealTime便成为了web开发者们津津乐道的话题。实时化的web应用，凭借其响应迅速、无需刷新、节省网络流量的特性，不仅让开发者们眼前一亮，更是为用户带来绝佳的网络体验。")]),e._v(" "),s("p",[e._v("近年来关于RealTime的实现，主要还是基于Ajax的拉取和Comet的推送。大家都知道Ajax，这是一种借助浏览器端JavaScript实现的异步无刷新请求功能：要客户端按需向服务器发出请求，并异步获取来自服务器的响应，然后按照逻辑更新当前页面的相应内容。但是这仅仅是"),s("strong",[e._v("拉取")]),e._v("啊，这并不是真正的RealTime：缺少服务器端的自动推送！因此，我们不得不使用另一种略复杂的技术Comet，只有当这两者配合起来，这个web应用才勉强算是个RealTime应用！")]),e._v(" "),s("h3",{attrs:{id:"hello-websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hello-websocket"}},[e._v("#")]),e._v(" Hello WebSocket！")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://raw.githubusercontent.com/abbshr/abbshr.github.io/master/source/postimg/wsc.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://raw.githubusercontent.com/abbshr/abbshr.github.io/master/source/postimg/wsc.png",alt:"WebSocket in Client Chrome"}}),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("不过随着HTML5草案的不断完善，越来越多的现代浏览器开始全面支持WebSocket技术了。至于WebSocket，我想大家或多或少都听说过。")]),e._v(" "),s("p",[e._v("这个WebSocket是一种全新的协议。它将TCP的Socket（套接字）应用在了web page上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于"),s("strong",[e._v("全双工")]),e._v("（双方同时进行双向通信）。")]),e._v(" "),s("p",[e._v("其实是这样的，WebSocket协议是借用HTTP协议的"),s("code",[e._v("101 switch protocol")]),e._v("来达到协议转换的，从HTTP协议切换成WebSocket通信协议。")]),e._v(" "),s("p",[e._v("再简单点来说，它就好像将Ajax和Comet技术的特点结合到了一起，只不过性能要高并且使用起来要方便的多（当然是之指在客户端方面。。）")]),e._v(" "),s("h3",{attrs:{id:"设计哲学"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计哲学"}},[e._v("#")]),e._v(" 设计哲学")]),e._v(" "),s("p",[e._v("RFC草案中已经说明，WebSocket的目的就是为了在基础上保证传输的数据量最少。\n这个协议是基于Frame而非Stream的，也就是说，数据的传输不是像传统的流式读写一样按字节发送，而是采用一帧一帧的Frame，并且每个Frame都定义了严格的数据结构，因此所有的信息就在这个Frame载体中。（后面会详细介绍这个Frame）")]),e._v(" "),s("h4",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[e._v("#")]),e._v(" 特点")]),e._v(" "),s("ul",[s("li",[e._v("基于TCP协议")]),e._v(" "),s("li",[e._v("具有命名空间")]),e._v(" "),s("li",[e._v("可以和HTTP Server共享同一port")])]),e._v(" "),s("h3",{attrs:{id:"打开连接-握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#打开连接-握手"}},[e._v("#")]),e._v(" 打开连接-握手")]),e._v(" "),s("p",[e._v("下面我先用自然语言描述一下WebSocket的工作原理：\n若要实现WebSocket协议，首先需要浏览器主动发起一个HTTP请求。")]),e._v(" "),s("p",[e._v("这个请求头包含“Upgrade”字段，内容为“websocket”（注：upgrade字段用于改变HTTP协议版本或换用其他协议，这里显然是换用了websocket协议），还有一个最重要的字段“Sec-WebSocket-Key”，这是一个随机的经过"),s("code",[e._v("base64")]),e._v("编码的字符串，像密钥一样用于服务器和客户端的握手过程。一旦服务器君接收到来自客户端的upgrade请求，便会将请求头中的“Sec-WebSocket-Key”字段提取出来，追加一个固定的“魔串”："),s("code",[e._v("258EAFA5-E914-47DA-95CA-C5AB0DC85B11")]),e._v("，并进行"),s("code",[e._v("SHA-1")]),e._v("加密，然后再次经过"),s("code",[e._v("base64")]),e._v("编码生成一个新的key，作为响应头中的“Sec-WebSocket-Accept”字段的内容返回给浏览器。一旦浏览器接收到来自服务器的响应，便会解析响应中的“Sec-WebSocket-Accept”字段，与自己加密编码后的串进行匹配，一旦匹配成功，便有建立连接的可能了（因为还依赖许多其他因素）。")]),e._v(" "),s("p",[e._v("这是一个基本的Client请求头：(我只写了关键的几个字段)")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Upgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: ************==\nSec-WebSocket-Version: **\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("Server正确接收后，会返回一个响应头：(同样只有关键的)")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Upgrade：websocket\nConnnection: Upgrade\nSec-WebSocket-Accept: ******************\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("这表示双方"),s("strong",[e._v("握手")]),e._v("成功了，之后就是全双工的通信。")]),e._v(" "),s("h3",{attrs:{id:"安全性限制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全性限制"}},[e._v("#")]),e._v(" 安全性限制")]),e._v(" "),s("p",[e._v("当你看完上面一节后一定会质疑该协议的保密性和安全性，看上去任何客户端都能够很容易的向WS服务器发起请求或伪装截获数据。WebSocket协议规定在连接建立时检查Upgrade请求中的某些字段（如"),s("code",[e._v("Origin")]),e._v("），对于不符合要求的请求立即截断；在通信过程中，也对Frame中的控制位做了很多限制，以便禁止异常连接。")]),e._v(" "),s("p",[e._v("对于握手阶段的检查，这种限制仅仅是在浏览器中，对于特殊的客户端（non-browser，如编码构造正确的请求头发送连接请求），这种源模型就失效了。")]),e._v(" "),s("p",[e._v("（后面会介绍通信过程中的"),s("strong",[e._v("连接关闭")]),e._v("种类与流程。）")]),e._v(" "),s("p",[e._v("除此之外，WebSocket也规定了加密数据传输方法，允许使用TLS/SSL对通信进行加密，类似HTTPS。默认情况下，ws协议使用80端口进行普通连接，加密的TLS连接默认使用443端口。")]),e._v(" "),s("h3",{attrs:{id:"和tcp、http协议的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#和tcp、http协议的关系"}},[e._v("#")]),e._v(" 和TCP、HTTP协议的关系")]),e._v(" "),s("p",[e._v("WebSocket是基于TCP的独立的协议。\n和HTTP的唯一关联就是HTTP服务器需要发送一个“Upgrade”请求，即"),s("code",[e._v("101 Switching Protocol")]),e._v("到HTTP服务器，然后由服务器进行协议转换。")]),e._v(" "),s("h3",{attrs:{id:"ws的子协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ws的子协议"}},[e._v("#")]),e._v(" ws的子协议")]),e._v(" "),s("p",[e._v("客户端向服务器发起握手请求的header中可能带有“Sec-WebSocket-Protocol”字段，用来指定一个特定的子协议，一旦这个字段有设置，那么服务器需要在建立连接的响应头中包含同样的字段，内容就是选择的子协议之一。")]),e._v(" "),s("p",[e._v("子协议的命名应该是注册过的（有一套规范）。\n为了避免潜在的冲突，建议子协议的源（发起者）使用ASCII编码的域名。\n例子：\n一个注册过的子协议叫“chat.xxx.com”，另一个叫“chat.xxx.org”。这两个子协议都会被server同时实现，server会动态的选择使用哪个子协议（取决于客户端发送过来的值）。")]),e._v(" "),s("h3",{attrs:{id:"extensions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#extensions"}},[e._v("#")]),e._v(" Extensions")]),e._v(" "),s("p",[e._v("扩展是用来增加ws协议一些新特性的，这里就不详细说了。")]),e._v(" "),s("h3",{attrs:{id:"建立连接部分代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#建立连接部分代码"}},[e._v("#")]),e._v(" 建立连接部分代码")]),e._v(" "),s("p",[e._v("上面说的仅仅是个概述，重要的是该如何在我们的web应用中使用或者说该如何建立一个基于WebSocket的应用呢？")]),e._v(" "),s("p",[e._v("我直说了，客户端使用WebSocket简直易如反掌，服务端实现WebSocket真是难的一B啊！尤其是我们现在还没有学过计算机网络，对一些网络底层的（如TCP/IP协议）知识了解的太少，理解并实现WebSocket确实不太容易。所以这次我先把WebSocket用提供一部分接口的高级语言来实现。")]),e._v(" "),s("p",[e._v("Node.js的异步I/O模型实在是太适合这种类型的应用了，因此我选择它作为I/O编程的首选。来看下面的JavaScript代码～：\n"),s("em",[e._v("Note：以下代码仅用于阐明原理，不可用于生产环境！")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("      var http = require('http');\n    var crypto = require('crypto');\n\n    var MAGIC_STRING = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\n    // HTTP服务器部分\n    var server = http.createServer(function (req, res) {\n      res.end('websocket test\\r\\n');\n    });\n\n    // Upgrade请求处理\n    server.on('upgrade', callback);\n\n    function callback(req, socket) {\n      // 计算返回的key\n      var resKey = crypto.createHash('sha1')\n        .update(req.headers['sec-websocket-key'] + MAGIC_STRING)\n        .digest('base64');\n\n      // 构造响应头\n      resHeaders = ([\n        'HTTP/1.1 101 Switching Protocols',\n        'Upgrade: websocket',\n        'Connection: Upgrade',\n        'Sec-WebSocket-Accept: ' + resKey\n      ]).concat('', '').join('\\r\\n');\n\n      // 添加通信数据处理\n      socket.on('data', function (data) {\n        // ...\n      });\n\n      // 响应给客户端\n      socket.write(resHeaders);\n    }\n\n    server.listen(3000);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br")])]),s("p",[e._v("上面的代码是等待客户端与之握手，当有客户端发出请求时，会按照“加密-编码-返回”的流程与之建立通信通道。既然连接已建立，接下来就是双方的通信了。为了让大家明白WebSocket的全程使用，在此之前有必要提一下支持WebSocket的底层协议的实现。")]),e._v(" "),s("h2",{attrs:{id:"协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[e._v("#")]),e._v(" 协议")]),e._v(" "),s("p",[e._v("协议这种东西就像某种魔法，赋予了计算机之间各种神奇的通信能力，但对用户来说却是透明的。\n不过对于WebSocket协议，我们可以透过IETF的RFC规范，看到关于实现WebSocket细节的每次变更与修正。")]),e._v(" "),s("h3",{attrs:{id:"frame"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#frame"}},[e._v("#")]),e._v(" Frame")]),e._v(" "),s("p",[e._v("前面已經说过了WebSocket在客户端与服务端的“Hand-Shaking”实现，所以这里讲数据传输。\nWebSocket传输的数据都是以"),s("code",[e._v("Frame")]),e._v("（帧）的形式实现的，就像TCP/UDP协议中的报文段"),s("code",[e._v("Segment")]),e._v("。下面就是一个Frame：（以bit为单位表示）")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-------+-+-------------+-------------------------------+\n |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n | |1|2|3|       |K|             |                               |\n +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n |     Extended payload length continued, if payload len == 127  |\n + - - - - - - - - - - - - - - - +-------------------------------+\n |                               |Masking-key, if MASK set to 1  |\n +-------------------------------+-------------------------------+\n | Masking-key (continued)       |          Payload Data         |\n +-------------------------------- - - - - - - - - - - - - - - - +\n :                     Payload Data continued ...                :\n + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n |                     Payload Data continued ...                |\n +---------------------------------------------------------------+\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[e._v("按照RFC中的描述：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("FIN： 1 bit")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("表示这是一个消息的最后的一帧。第一个帧也可能是最后一个。  \n%x0 : 还有后续帧  \n%x1 : 最后一帧\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("RSV1、2、3： 1 bit each")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("除非一个扩展经过协商赋予了非零值以某种含义，否则必须为0\n如果没有定义非零值，并且收到了非零的RSV，则websocket链接会失败\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("Opcode： 4 bit")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("解释说明 “Payload data” 的用途/功能\n如果收到了未知的opcode，最后会断开链接\n定义了以下几个opcode值:\n    %x0 : 代表连续的帧\n    %x1 : text帧\n    %x2 ： binary帧\n    %x3-7 ： 为非控制帧而预留的\n    %x8 ： 关闭握手帧\n    %x9 ： ping帧\n%xA :  pong帧\n%xB-F ： 为非控制帧而预留的\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("Mask： 1 bit")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("定义“payload data”是否被添加掩码\n如果置1， “Masking-key”就会被赋值\n所有从客户端发往服务器的帧都会被置1\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("Payload length： 7 bit | 7+16 bit | 7+64 bit")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("“payload data” 的长度如果在0~125 bytes范围内，它就是“payload length”，\n如果是126 bytes， 紧随其后的被表示为16 bits的2 bytes无符号整型就是“payload length”，\n如果是127 bytes， 紧随其后的被表示为64 bits的8 bytes无符号整型就是“payload length”\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("Masking-key： 0 or 4 bytes")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("所有从客户端发送到服务器的帧都包含一个32 bits的掩码（如果“mask bit”被设置成1），否则为0 bit。一旦掩码被设置，所有接收到的payload data都必须与该值以一种算法做异或运算来获取真实值。（见下文）\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("Payload data: (x+y) bytes")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('它是"Extension data"和"Application data"的总和，一般扩展数据为空。\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("Extension data: x bytes")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("除非扩展被定义，否则就是0\n任何扩展必须指定其Extension data的长度\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("Application data: y bytes")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('占据"Extension data"之后的剩余帧的空间\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])])])]),e._v(" "),s("p",[s("strong",[e._v("注意：这些数据都是以二进制形式表示的，而非ascii编码字符串")])]),e._v(" "),s("h4",{attrs:{id:"构造frame"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造frame"}},[e._v("#")]),e._v(" 构造Frame")]),e._v(" "),s("p",[e._v("Frame的结构已经清楚了，我们就构造一个Frame。\n在构造时，我们可以把Frame分成两段："),s("strong",[e._v("控制位")]),e._v("和"),s("strong",[e._v("数据位")]),e._v("。其中控制位就是"),s("strong",[e._v("Frame的前两字节")]),e._v("，包含FIN、Opcode等与该Frame的元信息。")]),e._v(" "),s("p",[s("strong",[e._v("Note：网络中使用大端次序（Big endian）表示大于一字节的数据，称之为网络字节序。")]),e._v("\nNode.js中提供了Buffer对象，专门用来弥补JavaScript在处理字节数据上的不足，这里正好可以用它来完成这个任务：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  // 控制位: FIN, Opcode, MASK, Payload_len\n  var preBytes = [], \n      payBytes = new Buffer('test websocket'), \n      mask = 0;\n      masking_key = Buffer.randomByte(4);\n\n  var dataLength = payBytes.length;\n\n  // 构建Frame的第一字节\n  preBytes.push((frame['FIN'] << 7) + frame['Opcode']);\n\n  // 处理不同长度的dataLength，构建Frame的第二字节（或第2～第8字节）\n  // 注意这里以大端字节序构建dataLength > 126的dataLenght\n  if (dataLength < 126) {\n    preBytes.push((frame['MASK'] << 7) + dataLength);\n  } else if (dataLength < 65536) {\n    preBytes.push(\n      (frame['MASK'] << 7) + 126, \n      (dataLength & 0xFF00) >> 8,\n      dataLength & 0xFF\n    );\n  } else {\n    preBytes.push(\n      (frame['MASK'] << 7) + 127,\n      0, 0, 0, 0,\n      (dataLength & 0xFF000000) >> 24,\n      (dataLength & 0xFF0000) >> 16,\n      (dataLength & 0xFF00) >> 8,\n      dataLength & 0xFF\n    );\n  }\n\n  preBytes = new Buffer(preBytes);\n\n  // 如果有掩码，就对数据进行加密，并构建之后的控制位\n  if (mask) {\n    preBytes = Buffer.concat([preBytes, masking_key]);\n    for (var i = 0; i < dataLength; i++) \n      payBytes[i] ^= masking_key[i % 4];\n  }\n\n  // 生成一个Frame\n  var frame = Buffer.concat([preBytes, payBytes]);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br")])]),s("p",[e._v("按照这种格式，就定义好了一个帧，客户端或者服务器就可以用这个帧来互传数据了。既然数据已经接收，接下来看看如何处理这些数据。")]),e._v(" "),s("h4",{attrs:{id:"masking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#masking"}},[e._v("#")]),e._v(" Masking")]),e._v(" "),s("p",[e._v("规范里解释了"),s("code",[e._v("Masking-key")]),e._v("掩码的作用了：就是当"),s("code",[e._v("mask")]),e._v("字段的值为1时，"),s("code",[e._v("payload-data")]),e._v("字段的数据需要经这个掩码进行解密。")]),e._v(" "),s("p",[e._v("在处理数据之前，我们要清楚一件事：服务器推送到客户端的消息中，"),s("code",[e._v("mask")]),e._v("字段是0,也就是说"),s("code",[e._v("Masking-key")]),e._v("为空。这样的话，数据的解析就不涉及到掩码，直接使用就行。")]),e._v(" "),s("p",[e._v("但是我们前面提到过，如果消息是从客户端发送到服务器，那么"),s("code",[e._v("mask")]),e._v("一定是1,"),s("code",[e._v("Masking-key")]),e._v("一定是一个32bit的值。下面我们来看看数据是如何解析的：")]),e._v(" "),s("p",[e._v("当消息到达服务器后，服务器程序就开始以字节为单位逐步读取这个帧，当读取到"),s("code",[e._v("payload-data")]),e._v("时，首先将数据按byte依次与"),s("code",[e._v("Masking-key")]),e._v("中的4个byte按照如下算法做异或：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('      //假设我们发送的"Payload data"以变量`data`表示，字节（byte）数为len;\n      //masking_key为4byte的mask掩码组成的数组\n    //offset：跳过的字节数\n\n    for (var i = 0; i < len; i++) {\n        var j = i % 4;\n        data[offset + i] ^= masking_key[j];\n    }\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("上面的JavaScript代码给出了掩码"),s("code",[e._v("Masking-key")]),e._v("是如何解密"),s("code",[e._v("Payload-data")]),e._v("的：先对i取模来获得要使用的masking-key的索引，然后用"),s("code",[e._v("data[offset + i]")]),e._v("与"),s("code",[e._v("masking_key[j]")]),e._v("做异或，从而得到真实的byte数据。")]),e._v(" "),s("h4",{attrs:{id:"控制帧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制帧"}},[e._v("#")]),e._v(" 控制帧")]),e._v(" "),s("p",[e._v("控制帧用来说明WebSocket的状态信息，用来控制分片、连接的关闭等等。所有的控制帧必须有一个小于等于125字节的payload，并且"),s("strong",[e._v("control Frames不允许被分片")]),e._v("。"),s("code",[e._v("Opcode")]),e._v("为"),s("code",[e._v("0x0")]),e._v("（持续的帧），"),s("code",[e._v("0x8")]),e._v("（关闭连接），"),s("code",[e._v("0x9")]),e._v("（Ping帧）和"),s("code",[e._v("0xA")]),e._v("（Pong帧）代表控制帧。")]),e._v(" "),s("p",[e._v("一般Ping Frame用来对一个有超时机制的套接字keepalive或者验证对方是否有响应。Pong Frame就是对Ping的回应。")]),e._v(" "),s("h4",{attrs:{id:"数据帧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据帧"}},[e._v("#")]),e._v(" 数据帧")]),e._v(" "),s("p",[e._v("前面我们总是谈到“控制帧”和“非控制帧”，想必大家已經看出来一些门路。其实数据帧就是非控制帧。因为这个帧并不是用来提供协议连接状态信息的。数据帧由最高符号位是0的"),s("code",[e._v("Opcode")]),e._v("确定，现在可用的几个数据帧的Opcode是"),s("code",[e._v("0x1")]),e._v("（utf-8文本）、"),s("code",[e._v("0x2")]),e._v("（二进制数据）。")]),e._v(" "),s("h3",{attrs:{id:"分片-fragment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分片-fragment"}},[e._v("#")]),e._v(" 分片（Fragment）")]),e._v(" "),s("p",[e._v("理论上来说，每个帧（Frame）的大小是没有限制的，因为payload-data在整个帧的最后。但是发送的数据有不能太大，否则 WebSocket 很可能无法"),s("a",{attrs:{href:"https://github.com/abbshr/abbshr.github.io/issues/22#issuecomment-261436452",target:"_blank",rel:"noopener noreferrer"}},[e._v("高效的利用网络带宽"),s("OutboundLink")],1),e._v("。那如果我们想传点大数据该怎么办呢？WebSocket协议给我们提供了一个方法：分片，将原本一个大的帧拆分成数个小的帧。下面是把一个大的Frame分片的图示：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  编号：      0  1  ....  n-2 n-1\n  分片：     |——|——|......|——|——|\n  FIN：      0  0  ....   0  1\n  Opcode：   !0 0  ....   0  0\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("由图可知，第一个分片的"),s("code",[e._v("FIN")]),e._v("为0，"),s("code",[e._v("Opcode")]),e._v("为非0值（0x1或0x2），最后一个分片的"),s("code",[e._v("FIN")]),e._v("为1，"),s("code",[e._v("Opcode")]),e._v("为0。中间分片的"),s("code",[e._v("FIN")]),e._v("和"),s("code",[e._v("Opcode")]),e._v("二者均为0。")]),e._v(" "),s("p",[s("strong",[e._v("Note1：消息的分片必须由发送者")]),e._v("按给定的顺序"),s("strong",[e._v("发送给接收者。")])]),e._v(" "),s("p",[s("em",[e._v("Note2：控制帧禁止分片")])]),e._v(" "),s("p",[s("strong",[e._v("Note3：接受者不必按顺序缓存整个frame来处理")])]),e._v(" "),s("h3",{attrs:{id:"关闭连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关闭连接"}},[e._v("#")]),e._v(" 关闭连接")]),e._v(" "),s("h4",{attrs:{id:"正常的连接关闭流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正常的连接关闭流程"}},[e._v("#")]),e._v(" 正常的连接关闭流程")]),e._v(" "),s("ol",[s("li",[e._v("发送关闭连接请求（Close Handshake）\n即发送"),s("code",[e._v("Close Frame")]),e._v("（Opcode为0x8）。一旦一端发送/接收了一个Close Frame，就开始了Close Handshake，并且连接状态变为"),s("code",[e._v("Closing")]),e._v("。\nClose Frame中如果包含Payload data，则data的"),s("strong",[e._v("前2字节")]),e._v("必须为两字节的无符号整形，（同样遵循网络字节序：BE）用于表示"),s("strong",[e._v("状态码")]),e._v("，如果2byte之后仍有内容，则应包含utf-8编码的"),s("strong",[e._v("关闭理由")]),e._v("。\n如果一端在之前未发送过Close Frame，则当他收到一个Close Frame时，必须回复一个Close Frame。但如果它正在发送数据，则可以推迟到当前数据发送完，再发送Close Frame。比如Close Frame在分片发送时到达，则要等到所有剩余分片发送完之后，才可以作出回复。")]),e._v(" "),s("li",[e._v("关闭WebSocket连接\n当一端已经收到Close Frame，并已发送了Close Frame时，就可以关闭连接了，close handshake过程结束。这时丢弃所有已经接收到的末尾字节。")]),e._v(" "),s("li",[e._v("关闭TCP连接\n当底层TCP连接关闭时，连接状态变为"),s("code",[e._v("Closed")]),e._v("。")])]),e._v(" "),s("h4",{attrs:{id:"clean-closed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#clean-closed"}},[e._v("#")]),e._v(" clean closed")]),e._v(" "),s("p",[e._v("如果TCP连接在Close handshake完成之后关闭，就表示WebSocket连接已经"),s("strong",[e._v("clean closed")]),e._v("（彻底关闭）了。\n如果WebSocket连接并未成功建立，状态也为连接已关闭，但并不是"),s("code",[e._v("clean closed")]),e._v("。")]),e._v(" "),s("h4",{attrs:{id:"正常关闭"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正常关闭"}},[e._v("#")]),e._v(" 正常关闭")]),e._v(" "),s("p",[e._v("正常关闭过程属于"),s("code",[e._v("clean close")]),e._v("，应当包含"),s("code",[e._v("close handshake")]),e._v("。")]),e._v(" "),s("p",[e._v("通常来讲，应该由服务器关闭底层TCP连接，而客户端应该等待服务器关闭连接，除非等待超时的话，那么自己关闭底层TCP连接。")]),e._v(" "),s("p",[e._v("服务器可以随时关闭WebSocket连接，而客户端不可以主动断开连接。")]),e._v(" "),s("h4",{attrs:{id:"异常关闭"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常关闭"}},[e._v("#")]),e._v(" 异常关闭")]),e._v(" "),s("ol",[s("li",[e._v("由于某种算法或规定，一端直接关闭连接。（特指在open handshake（打开连接）阶段）")]),e._v(" "),s("li",[e._v("底层连接丢失导致的连接中断。")])]),e._v(" "),s("h4",{attrs:{id:"连接失败"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#连接失败"}},[e._v("#")]),e._v(" 连接失败")]),e._v(" "),s("p",[e._v("由于某种算法或规范要求指定连接失败。这时，客户端和服务器必须关闭WebSocket连接。当一端得知连接失败时，"),s("strong",[e._v("不准")]),e._v("再处理数据，包括"),s("strong",[e._v("响应close frame")]),e._v("。")]),e._v(" "),s("h4",{attrs:{id:"从异常关闭中恢复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从异常关闭中恢复"}},[e._v("#")]),e._v(" 从异常关闭中恢复")]),e._v(" "),s("p",[e._v("为了防止海量客户端同时发起重连请求（reconnect），客户端应该推迟一个随机时间后重新连接，可以选择回退算法来实现，比如"),s("strong",[e._v("截断二进制指数退避算法")]),e._v("。")]),e._v(" "),s("h3",{attrs:{id:"关于补充"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于补充"}},[e._v("#")]),e._v(" 关于补充")]),e._v(" "),s("p",[e._v("这两篇blog里主要用自然语言讲了WebSocket的实现。代码的细节操作（例如：处理数据、安全处理等）并没有给出，因为核心实现原理已经阐明。")]),e._v(" "),s("p",[e._v("因为近期写了一个比较完整的WebSocket库"),s("a",{attrs:{href:"https://github.com/abbshr/RocketEngine",target:"_blank",rel:"noopener noreferrer"}},[e._v("RocketEngine"),s("OutboundLink")],1),e._v("，在编码过程中发现了好多需要注意的问题，特此加以补充和修正，增加了部分章节，改正了一些不精确的说法，同时将两篇日志合并。")]),e._v(" "),s("p",[e._v("2018年11月14日")])])}),[],!1,null,null,null);a.default=t.exports}}]);